[{"authors":["admin"],"categories":null,"content":"Vignesh is a candidate of the Master of Data Science program at The University of British Columbia. His experience in the financial services industry includes a Data Analyst role for the markets connectivity team in Citi as well as 5 years as a software engineer specializing in building high frequency trading applications. He has also passed the level 2 of the CFA program.\n","date":1615078034,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1615078034,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://vigneshrajakumar.github.io/author/vignesh-rajakumar/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/vignesh-rajakumar/","section":"authors","summary":"Vignesh is a candidate of the Master of Data Science program at The University of British Columbia. His experience in the financial services industry includes a Data Analyst role for the markets connectivity team in Citi as well as 5 years as a software engineer specializing in building high frequency trading applications.","tags":null,"title":"Vignesh Rajakumar","type":"authors"},{"authors":["Vignesh Rajakumar"],"categories":["Blog"],"content":"A Case Study in Object Oriented Programming: Catan in Python Object oriented programming can be fun and rewarding. When you really get into it, you almost get the feeling that the code builds itself after a point. When you\u0026rsquo;re taught Object Oriented Programming in a Software Engineering context at a college level computer science course, it\u0026rsquo;s often placed early on, right after you\u0026rsquo;ve been taught a new language (or right after you\u0026rsquo;re taught programming in general). This sometimes makes it hard to really appreciate what value it adds to your software engineering toolkit.\nI was recently playing a game of Catan and found the interaction between settlements, cities, roads and the hexagonal tiles particularly interesting (and no, I wasn\u0026rsquo;t doing this just because I was losing, why do you ask?). Trying to model these interaction and properties in code seemed like a tasty challenge, one that I can easily sink a weekend into. If I wanted to show the usefulness of object oriented programming, (Although, I should really pick a board game that didn\u0026rsquo;t have a 20-page rule book). I\u0026rsquo;m not going to try and build an entire working game engine for this blog post; just a few classes and interactions. By the end of this blog post, I hope to have answered that itching question you\u0026rsquo;ve always wanted to ask your high school programming teacher or your Intro to Software Engineering professor: What\u0026rsquo;s the big deal about Object Oriented Programming Anyway?\nCatan Brush-Up If you\u0026rsquo;re rusty in your Catan, this video does a pretty good job of explaining the rules. Each turn basically boils down to this:\nOOP\u0026rsquo;s core tenants Object Oriented programming has four main principles: Encapsulation, Abstraction, Inheritance and Polymorphism. I\u0026rsquo;d say that if you have a good intuitive understanding of the first three, you can build a strong understanding of and appreciation for OOP.\nAbstraction First, I\u0026rsquo;ll model the hexagonal tiles that are synonymous with Catan. There are 6 different types of tiles, and each one generates a different resource: Pastures generate Wool, Forests generate Wood, Hills generate Bricks, Mountains generate Ore, Fields generate Grain and Deserts generate \u0026hellip; well, nothing. Writing down definitions for all of these in this blog post is a bit pointless, so I am going to focus on two: Forests and Pastures.\nclass Tile(abc.ABC): @abc.abstractmethod def name(self): pass @abc.abstractmethod def generate_resource(self): pass @abc.abstractmethod def short_name(self): pass class Forest(Tile): def name(self): return \u0026quot;Forest\u0026quot; def generate_resource(self): return Wood() def short_name(self): return \u0026quot;fo\u0026quot; class Pasture(Tile): def name(self): print(\u0026quot;Pasture\u0026quot;) def generate_resource(self): return Wool() def short_name(self): return \u0026quot;pa\u0026quot; class GameTile: def __init__(self, number_label, tile, points, position): self.number_label = number_label self.tile = tile self.points = points self.position = position  The eagle-eyed among you would have noticed that I haven\u0026rsquo;t defined Wood and Wool anywhere yet. Good catch! Here they are:\nclass ResourceCard(abc.ABC): @abc.abstractmethod def name(self): pass class Wood(ResourceCard): def name(self): return \u0026quot;Wood\u0026quot; class Wool(ResourceCard): def name(self): return \u0026quot;Wool\u0026quot;  Its nothing fancy or complex, all it does is make each of the resource card objects human readable by returning a name. These definitions let me do something like this somewhere in my game engine code:\ndef game_loop(): # # ... complex engine code # # get the active player to roll the dice roll = player.roll_dice(dice) # get the GameTiles that have the label associated with current roll active_tiles = game_tiles[roll] # for each of the tiles that matched for game_tile in active_tiles: # for each point in the hexagonal tile for point in game_tile.points: # If the point has a setllement or a city if point.abode is not None: # get the owner reciever = point.abode.owner # Give him the resource Card! reciever.add_resource(game_tile.tile.generate_resource()) # # ... complex engine code #  There might be a lot going on there but focus on this specific line: reciever.get_resource(game_tile.tile.generate_resource()). That\u0026rsquo;s the game engine calling the generate_resource() method I wrote in the definition above. Since I \u0026lsquo;hid\u0026rsquo; away the logic to actually generate the resource into the Tile classes, I don\u0026rsquo;t have to manually check the type of each tile when I hand out the resource cards to the player!\nThis idea of \u0026lsquo;hiding away\u0026rsquo; code and logic that is not useful to the current situation is called Abstraction. Another intuitive way to think of abstraction is using code as building blocks: I used the implementation of the tiles' generate_resource() method to build upon for the game engine logic. Also, the Forest class itself builds upon the code defined in the Wood class.\nEncapsulation I hinted at the existence of a Player class in the game engine code above. Let\u0026rsquo;s look at it now:\nclass Player: def __init__(self, color): self.color = color self.victory_points = 0 self.resource_cards = ResourceCardDeck() self.development_cards = [] def add_resource(self, resource_card): \u0026quot;\u0026quot;\u0026quot; Adds the given resource into the player's hand \u0026quot;\u0026quot;\u0026quot; self.resource_cards.add_card(resource_card) def accept_trade(self, incoming_trade, requested_trade): \u0026quot;\u0026quot;\u0026quot; Adds the cards from the incoming trade to the player's hand and removes those from the requested trade both incoming_trade and requested_trade are dictionaries where the key is the card type and the value is the number of cards of that type. \u0026quot;\u0026quot;\u0026quot; for card in requested_trade: number_of_cards = requested_trade[card] self.resource_cards.remove_cards(card, number_of_cards) for card in incoming_trade: number_of_cards = incoming_trade[card] self.resource_cards.add_cards(card, number_of_cards) def add_development_card(self, card): \u0026quot;\u0026quot;\u0026quot; Adds the given development card into the players hand \u0026quot;\u0026quot;\u0026quot; self.development_cards.append(card)   Note: The implementation of adding and removing cards from the resource cards in the players hand is not simple and not relevant here, so I, wait for it, abstracted it away :)\n Each turn, a player could:\n Get resource cards if the die roll is in their favor. Use their resource cards to buy a development card. Trade resource cards with another player.  For the sake of simplicity, I am going to stick to modeling just these three actions. Each of these actions are handled in each of the three methods in the Player class. Each of those methods in turn, manipulate the resource cards or development cards in the player\u0026rsquo;s hand.\nWhat we\u0026rsquo;ve done here by clubbing together a classes data (the player\u0026rsquo;s hand) and functions that affect the data (the three actions above) into one class is called Encapsulation. It also makes it so that a player\u0026rsquo;s hand can only be modified by actions that happen to that player. (In a legal game, you wouldn\u0026rsquo;t have players stealing each others cards!). Encapsulation \u0026lsquo;protects\u0026rsquo; the classes data from code outside the class.\nInheritance No version of Catan is complete without the all-important Settlements and Cities. Here is what they look like in my code:\nclass Building(abc.ABC): def __init__(self, owner, name): self.owner = owner self.name = name def description(self): return \u0026quot;%s owned by %s\u0026quot; % (self.name, self.owner) class Abode(Building): def __init__(self, owner, name, victory_points): super.__init__(owner, name) self.victory_points = victory_points class Settlement(Abode): def __init__(self, owner): super.__init__(self, owner, \u0026quot;Settlement\u0026quot;, 1) class City(Abode): def __init__(self, owner): super.__init__(self, owner, \u0026quot;City\u0026quot;, 2) class Road(Building): def __init__(self, owner): super.__init__(self, owner, \u0026quot;Road\u0026quot;) class Point: def __init__(self, abode, position, n1, n2, n3): self.abode = abode self.n1 = n1 self.n2 = n2 self.n3 = n3  What I\u0026rsquo;ve done here is that I\u0026rsquo;ve leverage the is-a relationship some of these buildings have. For example, Settlements and Cities are similar in that the count towards a player\u0026rsquo;s victory points. I called these victory point generating buildings Abodes. Cities and Settlements are Abodes; Roads are not. They are all still buildings though, and can be owned by players.\nI\u0026rsquo;ve modeled these hierarchical relationships using Inheritance. Inheritance often goes hand-in-hand with abstraction. You can see it in action here: I abstracted away code that is specific to a city into the City class.\nConclusion What\u0026rsquo;s covered in this blog post is just the tip of the iceberg though! There is still quite a lot I didn\u0026rsquo;t cover: Delegation, Polymorphism, Dynamic Dispatch (We did do a fair bit of this in this post ,though) and Composition. However, my intention with this post was to hopefully help you build an intuitive understanding of why OOP is preached so much, not to teach it outright.\nHopefully, you saw what I meant when I meant when I talked about the code building itself if you approach your problem with strong Object Oriented Programming ideals. I\u0026rsquo;m hoping that reading this blog post encourages you to try and model your favorite board game! (If its Catan, I\u0026rsquo;m open to any improvements you might suggest to what I\u0026rsquo;ve written.)\nThe demo code I used in this post can be found on my GitHub.\n","date":1615078034,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1615078034,"objectID":"b26b88570e0f5660d529c20a753e2128","permalink":"https://vigneshrajakumar.github.io/post/case-study/","publishdate":"2021-03-06T19:47:14-05:00","relpermalink":"/post/case-study/","section":"post","summary":"An attempt at explaining why Object Oriented Programming is touted to be the saviour of our times","tags":["Academic"],"title":"A Case Study in Object Oriented Programming: Catan in Python","type":"post"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a0db3bde5334134dd6b7b43bf0f4f19d","permalink":"https://vigneshrajakumar.github.io/project/movie-selection/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/project/movie-selection/","section":"project","summary":"(_Contributed to_) Building a Dashboard with Plotly and Dash. _[Image Source](https://unsplash.com/photos/EOQhsfFBhRk)_","tags":["Python","Dash","Plotly"],"title":"Dashboard for Movie Selection","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a53975d5b9a80e8d44286a2f8c65826f","permalink":"https://vigneshrajakumar.github.io/project/airbnb-recommend/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/project/airbnb-recommend/","section":"project","summary":"Using XGBoost to predict listing prices in Toronto. _[Image Source](https://unsplash.com/photos/lg3TETZvqv4)_","tags":["Python","MachineLearning","XGBoost"],"title":"Price Recommendations for AirBnb listings","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8f66d660a9a2edc2d08e68cc30f701f7","permalink":"https://vigneshrajakumar.github.io/project/internal-project/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/project/internal-project/","section":"project","summary":"An exercise to model the _Settlers of Catan_ game in python. _[Image Source](https://pixabay.com/photos/game-board-catan-leisure-340574/)_","tags":["Python"],"title":"PyCatan","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"d2bc86c26d7c0e21c5200e4ebf037183","permalink":"https://vigneshrajakumar.github.io/project/wine-predict/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/project/wine-predict/","section":"project","summary":"(_Contributed to_) using Random Forests to predict the quality of wines. _[Image Source](https://unsplash.com/photos/aF1NPSnDQLw)_","tags":["Python","MachineLearning"],"title":"Wine Quality Predictions","type":"project"}]