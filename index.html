#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

void boardSetup (char board[][26], int n);
bool positionInBounds (int n, char row, char col);
char opponent (char colour);
int movesAvailable (char board[][26], int n, char colour, char moves[][3]);
bool checkLegalInDirection(char board[][26], int n, char row, char col, char colour, int deltaRow, int deltaCol);
void playGame(char board[][26], int n, char colour, char compColour);
void findScores(char board[][26], int n, char compColour, char moves[][3], int moveNumber);
void printboard(char board[][26], int n);
void flipCoins (char board[][26], int n, char colour, char row, char col);
bool checkIfMoveValid(char moves[][3], char row, char col, int movesAvail);


int main (void) {
    int n;
    char Colour, compColour;
    char board[26][26];
    printf("Enter board dimension: ");
    scanf("%d", &n);
    printf ("Computer plays (B/W): ");
    scanf(" %c", &compColour);
    Colour = opponent(compColour);
    boardSetup(board, n);
  
    //movesAvailable(board, n, 'W');
    //movesAvailable(board, n, 'B');
    playGame(board, n, Colour, compColour);
    
    return 0;
}



// Function to setup the board
void boardSetup (char board[26][26], int n) {
    int i, j;
    printf("  ");
    // For loops for the rows
    for (i=0; i<n; i++)
        printf("%c", i+'a');
    // Nested loop for rows and cols to declare the unoccupied position
    for (i=0; i<n; i++) {
        for (j=0; j<n; j++)
            board[i][j]='U';
    }
    // The game starts from the centre of the board
    // White starts of with (b,b) and (c,c)
    board[n/2][(n/2)]='W';
    board[(n/2)-1][(n/2)-1]='W';
    
    // Black starts of with (b,c) and (c,b)
    board[(n/2)-1][n/2]='B';
    board[n/2][(n/2)-1]='B';
    
    // To print the name of col and row
    for (i=0; i<n; i++) {
        printf("\n%c ", i+'a');
        for (j=0; j<n; j++)
            printf("%c", board[i][j]);
    }
    printf("\n");
}

bool positionInBounds (int n, char row, char col) {
    if ((row-'a' >= 0) && (row-'a' <n) && (col-'a' >= 0) && (col-'a' < n))
        return true;
    else
        return false;
}


char opponent (char colour) {
    if (colour == 'B')
        return 'W';
    else
        return 'B';
}


bool checkLegalInDirection(char board[][26], int n, char row, char col, char colour, int deltaRow, int deltaCol) {
    int i = row-'a';
    int j = col-'a';
    int r = 0, c = 0;
    
    // The new row and coloumn are given by r and c
    int myCount = 1;

    r = i +(myCount*deltaRow);
    c = j +(myCount*deltaCol);
    
    // When this position is in bounds and that position has opponent's colour, myCount increases
    while (positionInBounds(n, 'a'+r, 'a'+c) && (board[r][c] != colour) && (board[r][c] != 'U')) {
        myCount++;
        // Repeats in the loop
        r = i +(myCount*deltaRow);
        c = j +(myCount*deltaCol);
        if(board[r][c] == 'U' || positionInBounds(n, 'a'+r, 'a'+c) != true){
            myCount = 0;
        }

    }
    
    // If the position is in bounds and that position is unoccupied, the direction of movement is legal and hence prints that move
    if (myCount > 1) {
        return true;
    }
    
    return false;
}




int movesAvailable (char board[][26], int n, char colour, char moves[][3]) {

    int moveNumber = 0;
    int i, j, deltaRow, deltaCol;

    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            bool legal = false;

            if (board[i][j] == 'U') {
                
                for (deltaRow = -1; deltaRow <= 1; deltaRow++) {

                    for (deltaCol = -1; deltaCol <= 1; deltaCol++) {
                        
                        if (deltaRow == 0 && deltaCol == 0){;}

                        else{
                            if (checkLegalInDirection(board, n, ('a'+i), ('a'+j), colour, deltaRow, deltaCol)){
                                moves[moveNumber][0] = 'a' + i;
                                moves[moveNumber][1] = 'a' + j;
                                moves[moveNumber][2] = 0;
                                moveNumber++;
                                legal = true;
                                break;
                            }
                        }
                    }
                    if (legal == true)
                        break;
                }
            }
        }
    }
    
    return moveNumber;
}

void findScores (char board[][26], int n, char compColour, char moves[][3], int moveNumber) {
    for(int i = 0; i < moveNumber; i++){
        int score = 0;
        int deltaRow, deltaCol;
        
        for (deltaRow = -1; deltaRow <= 1; deltaRow++) {
            // If the 'i'th row and 'j'th coloumn has my colour, the move is made except for (0,0)
            for (deltaCol = -1; deltaCol <= 1; deltaCol++) {
                if (deltaRow == 0 && deltaCol == 0){
                }
                // If that position is not (0,0) and it is in bounds, then it checks legal in direction and legal variable is true.
                else{
                    if (checkLegalInDirection(board, n, moves[i][0], moves[i][1], compColour, deltaRow, deltaCol)){
                        
                        int myCount = 1;
                        
                        int r = moves[i][0] - 'a' + (myCount*deltaRow);
                        int c = moves[i][1] - 'a' + (myCount*deltaCol);
                        
                        // When this position is in bounds and that position has opponent's colour, myCount increases
                        while (board[r][c] != compColour) {
                            myCount++;
                            score++;
                            // Repeats in the loop
                            r = moves[i][0] - 'a' + (myCount*deltaRow);
                            c = moves[i][1] - 'a' + (myCount*deltaCol);
                        }
                      
                    }
                }
            }

        }
        moves[i][2] = score;
    }
}


void flipCoins (char board[][26], int n, char colour, char row, char col) {
    
    int myCount;
    int deltaRow, deltaCol;
    for (deltaRow = -1; deltaRow <= 1; deltaRow++) {
        // If the 'i'th row and 'j'th coloumn has my colour, the move is made except for (0,0)
        for (deltaCol = -1; deltaCol <= 1; deltaCol++) {
            if (deltaRow == 0 && deltaCol == 0){
            }
            // If that position is not (0,0) and it is in bounds, then it checks legal in direction and legal variable is true.
            else
               if(checkLegalInDirection(board, n, row, col, colour, deltaRow, deltaCol) == true){

                    myCount = 1;
                    int r = row - 'a' +(myCount*deltaRow);
                    int c = col - 'a' +(myCount*deltaCol);
                    while (board[r][c] != colour) {
                        board[r][c] = colour;
                        myCount++;
                        
                        r = row - 'a' +(myCount*deltaRow);
                        c = col - 'a' +(myCount*deltaCol);
                    }
                }
        }
    }
    board[row - 'a'][col - 'a'] = colour;
}

void printBoard(char board[][26], int n){
    printf("  ");
    int i, j;
    for(i=0;i<n;i++){
        printf("%c",'a'+i);
    }
    printf("\n");

    for(i=0;i<n;i++){
        printf("%c ",'a'+i);
        for(j=0;j<n;j++){
            printf("%c",board[i][j]);
        }
        printf("\n");
    }
}

bool checkIfMoveValid(char moves[][3], char row, char col, int movesAvail) {
    for (int k=0;k<movesAvail;k++) {
        if(moves[k][0]==row && moves[k][1]==col)
            return true;
    }
    return false;
}

void playGame(char board[][26], int n, char colour, char compColour){

    bool isFull = false;
    bool isGameOver = false;
    int turn = 0;
    int movesAvail = 0;
    char row, col;
    int ctr = 0;
    int bCtr = 0;
    int wCtr = 0;
    if(compColour == 'B'){
        turn = 0;
    }else{
        turn = 1;
    }
    
    while (isFull == false && isGameOver == false ){ //Conditions for two consecutive moves not available
        char moves[n*n][3];
        isFull = true;
        
        if(turn % 2 == 0){
            //computer's turn
            movesAvail = movesAvailable(board, n, compColour, moves);
            
            if(movesAvail > 0){
                //Play
                findScores(board, n, compColour, moves, movesAvail);
                
                int k;
                int maxPos = 0;
                for (k=1; k< movesAvail; k++) {
                    if(moves[k][2] > moves[k][maxPos]){
                        maxPos = k;
                    }
                }
                printf("Computer places %c at %c%c.\n", compColour, moves[maxPos][0], moves[maxPos][1]);
                flipCoins (board, n, compColour, moves[maxPos][0], moves[maxPos][1]);
                printBoard(board, n);
                
            }else{
                printf("%c player has no valid move.\n", compColour);
            }
            
        }else{
            //player's turn
            movesAvail = movesAvailable(board, n, colour, moves);
            if (movesAvail > 0) {
                findScores(board, n, colour, moves, movesAvail);
                printf("Enter move for colour %c (RowCol): ", colour);
                scanf(" %c%c", &row, &col);
                //check if move is valid
                if(checkIfMoveValid(moves, row, col, movesAvail)) {
                    flipCoins(board, n, colour, row, col);
                    printBoard(board, n);
                } else {
                    ctr = 1;
                }
            }
            
            else {
                printf("%c player has no valid move.\n", colour);
            }
        }
        if (ctr == 1) {
            printf("Invalid move.\n");
            isGameOver = true;
        }
    
        turn++;
        
        int i,j;
        wCtr = 0;
        bCtr = 0;
        for(i = 0; i < n; i++){
            for(j = 0; j < n; j++){
                if(board[i][j] == 'U'){
                    isFull = false;
                    if(isGameOver==false) {
                        break;
                    }
                } else if(board[i][j] == 'W'){
                    wCtr++;
                } else if(board[i][j] == 'B'){
                    bCtr++;
                }
            }
        }
    }
    if(isFull || isGameOver) {
        if(bCtr>wCtr){
            printf("B player wins.\n");
        } else if(wCtr>bCtr) {
            printf("W player wins.\n");
        } else {
            printf("Draw!.\n");
        }
    }
}
